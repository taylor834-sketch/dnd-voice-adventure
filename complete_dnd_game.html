<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé≤ Epic Voice D&D Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cinzel+Decorative:wght@400;700&family=MedievalSharp&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Cinzel', serif;
            margin: 0;
            padding: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(139, 69, 19, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(34, 139, 34, 0.2) 0%, transparent 50%),
                linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 25%, #2d1b1b 50%, #1a2d1a 75%, #0a0a0a 100%);
            background-attachment: fixed;
            color: #f4e4bc;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Medieval parchment texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 25% 25%, rgba(139, 69, 19, 0.1) 0%, transparent 25%),
                radial-gradient(circle at 75% 75%, rgba(139, 69, 19, 0.05) 0%, transparent 30%),
                linear-gradient(45deg, transparent 40%, rgba(139, 69, 19, 0.02) 50%, transparent 60%);
            pointer-events: none;
            z-index: -1;
        }
        
        .game-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar main battle"
                "sidebar controls battle";
            grid-template-columns: 320px 1fr 400px;
            grid-template-rows: 100px 1fr 220px;
            height: 100vh;
            gap: 15px;
            padding: 15px;
        }
        
        .header {
            grid-area: header;
            background: 
                linear-gradient(135deg, rgba(139, 69, 19, 0.9) 0%, rgba(160, 82, 45, 0.9) 100%),
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><polygon fill="%23654321" points="0,0 5,10 0,20 95,20 100,10 95,0"/></svg>');
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                0 8px 32px rgba(139, 69, 19, 0.4),
                inset 0 2px 4px rgba(255, 215, 0, 0.2),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            border: 3px solid #8b4513;
            position: relative;
        }
        
        .header::before {
            content: '‚öúÔ∏è';
            position: absolute;
            left: 30px;
            font-size: 2em;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .header::after {
            content: '‚öúÔ∏è';
            position: absolute;
            right: 30px;
            font-size: 2em;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .sidebar {
            grid-area: sidebar;
            background: 
                linear-gradient(145deg, rgba(70, 50, 30, 0.95) 0%, rgba(50, 35, 20, 0.95) 100%);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 2px solid #8b4513;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(139, 69, 19, 0.3);
            overflow-y: auto;
            position: relative;
        }
        
        .sidebar::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #8b4513, transparent);
            border-radius: 2px;
        }
        
        .main-scene {
            grid-area: main;
            background: 
                linear-gradient(145deg, rgba(40, 60, 80, 0.95) 0%, rgba(30, 45, 60, 0.95) 100%);
            border-radius: 20px;
            padding: 25px;
            position: relative;
            overflow: hidden;
            border: 2px solid #4682b4;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(70, 130, 180, 0.3);
        }
        
        .battle-map {
            grid-area: battle;
            background: 
                linear-gradient(145deg, rgba(60, 40, 40, 0.95) 0%, rgba(45, 30, 30, 0.95) 100%);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid #8b0000;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(139, 0, 0, 0.3);
        }
        
        .controls {
            grid-area: controls;
            background: 
                linear-gradient(145deg, rgba(40, 60, 40, 0.95) 0%, rgba(30, 45, 30, 0.95) 100%);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid #228b22;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(34, 139, 34, 0.3);
        }
        
        .scene-image {
            width: 100%;
            height: 280px;
            background: linear-gradient(45deg, #2d5016, #4a7c59);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #f4e4bc;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            margin-bottom: 20px;
            position: relative;
            border: 3px solid #8b4513;
            box-shadow: 
                0 6px 24px rgba(0, 0, 0, 0.5),
                inset 0 2px 4px rgba(255, 215, 0, 0.2);
            transition: all 0.5s ease;
        }
        
        .scene-overlay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            background: 
                linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(139, 69, 19, 0.8) 100%);
            padding: 15px;
            border-radius: 12px;
            font-size: 14px;
            border: 1px solid #8b4513;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.7);
        }
        
        .narrative-text {
            background: 
                linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 20, 0.9) 100%);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #8b4513;
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 15px;
            max-height: 280px;
            overflow-y: auto;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(139, 69, 19, 0.3);
        }
        
        .battle-grid {
            width: 100%;
            height: 220px;
            background: 
                linear-gradient(45deg, rgba(139, 69, 19, 0.1) 25%, transparent 25%),
                linear-gradient(-45deg, rgba(139, 69, 19, 0.1) 25%, transparent 25%),
                linear-gradient(90deg, #654321 1px, transparent 1px),
                linear-gradient(#654321 1px, transparent 1px),
                radial-gradient(circle at 50% 50%, rgba(139, 69, 19, 0.3) 0%, rgba(45, 30, 20, 0.8) 100%);
            background-size: 50px 50px, 50px 50px, 25px 25px, 25px 25px, 100% 100%;
            border-radius: 12px;
            position: relative;
            border: 3px solid #8b4513;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(139, 69, 19, 0.3);
        }
        
        .game-piece {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            position: absolute;
            border: 3px solid #ffd700;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            cursor: grab;
            transition: all 0.3s ease;
            user-select: none;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.6),
                0 0 8px rgba(255, 215, 0, 0.3);
        }
        
        .game-piece:active {
            cursor: grabbing;
        }
        
        .player-piece {
            background: radial-gradient(circle, #4CAF50 0%, #2e7d32 100%);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .enemy-piece {
            background: radial-gradient(circle, #f44336 0%, #c62828 100%);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .npc-piece {
            background: radial-gradient(circle, #2196F3 0%, #1565c0 100%);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .game-piece:hover {
            transform: scale(1.4);
            z-index: 10;
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.8),
                0 0 16px rgba(255, 215, 0, 0.6);
        }
        
        .world-item {
            background: 
                linear-gradient(135deg, rgba(139, 69, 19, 0.6) 0%, rgba(70, 35, 20, 0.8) 100%);
            padding: 15px;
            margin: 12px 0;
            border-radius: 12px;
            border: 2px solid #8b4513;
            font-size: 13px;
            line-height: 1.5;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.5),
                inset 0 1px 2px rgba(255, 215, 0, 0.2);
            transition: all 0.3s ease;
        }
        
        .world-item:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.6),
                inset 0 1px 2px rgba(255, 215, 0, 0.3);
        }
        
        .world-item.quest {
            border-left: 5px solid #ffd700;
        }
        
        .world-item.character {
            border-left: 5px solid #ff6b6b;
        }
        
        .world-item.location {
            border-left: 5px solid #4ecdc4;
        }
        
        .world-item.notes {
            border-left: 5px solid #a855f7;
        }
        
        .voice-button {
            width: 100%;
            padding: 18px;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            font-weight: 600;
            border: 3px solid #8b4513;
            border-radius: 15px;
            cursor: pointer;
            margin: 12px 0;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 215, 0, 0.2);
        }
        
        .voice-button::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ffd700, #8b4513, #ffd700);
            border-radius: 15px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .voice-button:hover::before {
            opacity: 0.7;
        }
        
        .voice-button.listening {
            background: linear-gradient(135deg, #2e7d32 0%, #4caf50 100%);
            color: white;
            animation: pulse 2s infinite;
            border-color: #4caf50;
        }
        
        .voice-button.idle {
            background: linear-gradient(135deg, #8b4513 0%, #cd853f 100%);
            color: #f4e4bc;
            border-color: #cd853f;
        }
        
        .voice-button.speaking {
            background: linear-gradient(135deg, #7b1fa2 0%, #9c27b0 100%);
            color: white;
            animation: speaking 1s infinite alternate;
            border-color: #9c27b0;
        }
        
        @keyframes pulse {
            0% { 
                box-shadow: 
                    0 6px 20px rgba(0, 0, 0, 0.4),
                    0 0 0 0 rgba(76, 175, 80, 0.7); 
            }
            70% { 
                box-shadow: 
                    0 6px 20px rgba(0, 0, 0, 0.4),
                    0 0 0 15px rgba(76, 175, 80, 0); 
            }
            100% { 
                box-shadow: 
                    0 6px 20px rgba(0, 0, 0, 0.4),
                    0 0 0 0 rgba(76, 175, 80, 0); 
            }
        }
        
        @keyframes speaking {
            0% { transform: scale(1); }
            100% { transform: scale(1.03); }
        }

        @keyframes battlePulse {
            0% { 
                box-shadow: 
                    0 4px 20px rgba(0, 0, 0, 0.6), 
                    inset 0 2px 4px rgba(139, 69, 19, 0.3); 
            }
            100% { 
                box-shadow: 
                    0 4px 20px rgba(220, 20, 60, 0.8), 
                    inset 0 2px 4px rgba(220, 20, 60, 0.4); 
            }
        }

        @keyframes headerPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .status-bar {
            background: 
                linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 20, 0.9) 100%);
            padding: 12px;
            border-radius: 12px;
            margin: 12px 0;
            font-size: 14px;
            text-align: center;
            transition: all 0.3s ease;
            border: 2px solid #8b4513;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
        }
        
        .status-bar.listening {
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.8) 0%, rgba(76, 175, 80, 0.9) 100%);
            border-color: #4caf50;
            color: #e8f5e8;
        }
        
        .status-bar.processing {
            background: linear-gradient(135deg, rgba(245, 124, 0, 0.8) 0%, rgba(255, 152, 0, 0.9) 100%);
            border-color: #ff9800;
            color: #fff8e1;
        }
        
        .status-bar.speaking {
            background: linear-gradient(135deg, rgba(123, 31, 162, 0.8) 0%, rgba(156, 39, 176, 0.9) 100%);
            border-color: #9c27b0;
            color: #f3e5f5;
        }
        
        .status-bar.error {
            background: linear-gradient(135deg, rgba(198, 40, 40, 0.8) 0%, rgba(244, 67, 54, 0.9) 100%);
            border-color: #f44336;
            color: #ffebee;
        }

        .status-bar.success {
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.8) 0%, rgba(76, 175, 80, 0.9) 100%);
            border-color: #4caf50;
            color: #e8f5e8;
        }
        
        h1 {
            margin: 0;
            color: #ffd700;
            font-family: 'Cinzel Decorative', serif;
            font-size: 2.2em;
            font-weight: 700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            letter-spacing: 2px;
        }
        
        h3 {
            color: #ffd700;
            margin-bottom: 15px;
            font-family: 'Cinzel', serif;
            font-size: 1.3em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            border-bottom: 2px solid #8b4513;
            padding-bottom: 8px;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 12px;
            margin: 6px 0;
            border: 2px solid #8b4513;
            border-radius: 10px;
            background: 
                linear-gradient(135deg, rgba(139, 69, 19, 0.3) 0%, rgba(70, 35, 20, 0.5) 100%);
            color: #f4e4bc;
            font-family: 'Cinzel', serif;
            font-size: 13px;
            box-sizing: border-box;
            transition: all 0.3s ease;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 0 12px rgba(255, 215, 0, 0.4);
        }
        
        input::placeholder, textarea::placeholder {
            color: #c9b037;
        }
        
        button {
            padding: 12px 16px;
            margin: 6px 4px;
            border: 2px solid;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #8b0000 0%, #dc143c 100%);
            color: white;
            border-color: #dc143c;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #2e7d32 0%, #4caf50 100%);
            color: white;
            border-color: #4caf50;
        }
        
        .btn-info {
            background: linear-gradient(135deg, #1565c0 0%, #2196f3 100%);
            color: white;
            border-color: #2196f3;
        }
        
        .btn-settings {
            background: linear-gradient(135deg, #8b4513 0%, #cd853f 100%);
            color: #f4e4bc;
            border-color: #cd853f;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
        }
        
        .btn-primary:hover { border-color: #ff1744; }
        .btn-secondary:hover { border-color: #66bb6a; }
        .btn-info:hover { border-color: #42a5f5; }
        .btn-settings:hover { border-color: #ffd700; }
        
        .small-text {
            font-size: 11px;
            color: #c9b037;
            line-height: 1.4;
        }
        
        .hidden {
            display: none;
        }
        
        .dice-result {
            display: inline-block;
            padding: 6px 12px;
            background: linear-gradient(135deg, #ffd700 0%, #ffb300 100%);
            border-radius: 8px;
            color: #8b4513;
            font-weight: bold;
            margin: 0 6px;
            border: 2px solid #8b4513;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
        }
        
        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            box-shadow: 0 0 8px currentColor;
        }
        
        .connection-indicator.connected {
            background: #4caf50;
            color: #4caf50;
        }
        
        .connection-indicator.disconnected {
            background: #f44336;
            color: #f44336;
        }
        
        .message-user {
            margin: 12px 0;
            padding: 15px;
            background: 
                linear-gradient(135deg, rgba(139, 0, 0, 0.3) 0%, rgba(220, 20, 60, 0.2) 100%);
            border-left: 4px solid #dc143c;
            border-radius: 10px;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .message-dm {
            margin: 12px 0;
            padding: 15px;
            background: 
                linear-gradient(135deg, rgba(46, 125, 50, 0.3) 0%, rgba(76, 175, 80, 0.2) 100%);
            border-left: 4px solid #4caf50;
            border-radius: 10px;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .message-system {
            margin: 12px 0;
            padding: 12px;
            background: 
                linear-gradient(135deg, rgba(255, 193, 7, 0.3) 0%, rgba(255, 152, 0, 0.2) 100%);
            border-left: 4px solid #ffc107;
            border-radius: 10px;
            font-size: 13px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        /* Settings Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: 
                linear-gradient(145deg, rgba(70, 50, 30, 0.98) 0%, rgba(50, 35, 20, 0.98) 100%);
            margin: 5% auto;
            padding: 30px;
            border: 3px solid #8b4513;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .modal-content::before {
            content: '';
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #ffd700, transparent);
            border-radius: 2px;
        }
        
        .close {
            color: #ffd700;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            margin-top: -10px;
        }
        
        .close:hover {
            color: #ffb300;
        }
        
        @media (max-width: 1200px) {
            .game-container {
                grid-template-areas: 
                    "header"
                    "main"
                    "battle"
                    "controls"
                    "sidebar";
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto auto;
                height: auto;
                min-height: 100vh;
            }
            
            .sidebar {
                order: 5;
            }
            
            .btn-settings {
                position: fixed;
                top: 15px;
                right: 15px;
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(139, 69, 19, 0.3);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #8b4513, #cd853f);
            border-radius: 4px;
            border: 1px solid #654321;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #cd853f, #deb887);
        }
    </style>
</head>
<body>
    <!-- Settings Button -->
    <button class="btn-settings" onclick="openSettings()" title="Adventure Settings">
        ‚öôÔ∏è
    </button>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSettings()">&times;</span>
            <h1 style="text-align: center; margin-bottom: 30px;">üõ†Ô∏è Adventure Settings</h1>
            
            <h3>üîë API Configuration</h3>
            <input type="password" id="openaiKey" placeholder="OpenAI API Key (required for AI DM)">
            <input type="password" id="elevenLabsKey" placeholder="ElevenLabs API Key (optional for premium voice)">
            <select id="elevenLabsVoice">
                <option value="">Select Voice (optional)</option>
                <option value="21m00Tcm4TlvDq8ikWAM">Rachel (Calm female)</option>
                <option value="AZnzlk1XvdvUeBnXmlld">Domi (Strong female)</option>
                <option value="ErXwobaYiN019PkySvjV">Antoni (Well-rounded male)</option>
                <option value="TxGEqnHWrfWFTfGW9XjX">Josh (Deep male)</option>
                <option value="pNInz6obpgDQGcFmaJgB">Adam (Deep male)</option>
            </select>
            
            <h3>‚òÅÔ∏è Cloud Storage</h3>
            <input type="text" id="backendUrl" placeholder="Google Apps Script URL (optional for cloud saves)">
            
            <h3>üéÆ Game Options</h3>
            <label style="font-size: 14px; display: block; margin: 10px 0;">
                <input type="checkbox" id="enableVoice" checked> Enable Voice Response
            </label>
            <label style="font-size: 14px; display: block; margin: 10px 0;">
                <input type="checkbox" id="autoSync" checked> Auto-sync to Cloud Database
            </label>
            
            <div style="margin: 20px 0;">
                <div style="display: flex; gap: 10px; margin: 15px 0;">
                    <button onclick="testConnection()" class="btn-info" style="flex: 1;">üîó Test AI</button>
                    <button onclick="testBackendConnection()" class="btn-info" style="flex: 1;">üîó Test Cloud</button>
                </div>
                <div id="connectionStatus" class="small-text" style="text-align: center; padding: 10px;">
                    <span class="connection-indicator disconnected"></span>AI: ‚ùå | Cloud: ‚ùå
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 30px;">
                <button onclick="saveAndCloseSettings()" class="btn-secondary" style="flex: 2;">üíæ Save & Continue Adventure</button>
                <button onclick="clearApiKeys()" class="btn-primary" style="flex: 1;">üóëÔ∏è Clear All</button>
            </div>
            
            <p class="small-text" style="text-align: center; margin-top: 20px;">
                üîí Your API keys are stored securely in your browser only.
            </p>
        </div>
    </div>

    <div class="game-container">
        <div class="header">
            <h1>üé≤ Epic Voice D&D Adventure</h1>
        </div>
        
        <div class="sidebar">
            <h3>üåç Your World</h3>
            
            <div class="world-item quest">
                <strong>üó°Ô∏è Active Quests:</strong><br>
                <div id="activeQuests"><em>No active quests discovered yet</em></div>
            </div>
            
            <div class="world-item character">
                <strong>üë• Known Characters:</strong><br>
                <div id="knownCharacters"><em>No characters met yet</em></div>
            </div>
            
            <div class="world-item location">
                <strong>üó∫Ô∏è Explored Locations:</strong><br>
                <div id="knownLocations"><em>No locations discovered yet</em></div>
            </div>
            
            <div class="world-item notes">
                <strong>üìù Important Lore:</strong><br>
                <div id="importantNotes"><em>No lore recorded yet</em></div>
            </div>
            
            <div style="display: flex; gap: 8px; margin: 20px 0;">
                <button onclick="saveGameState()" class="btn-secondary" style="flex: 1;">üíæ Save</button>
                <button onclick="loadGameState()" class="btn-info" style="flex: 1;">üìÇ Load</button>
                <button onclick="newGame()" class="btn-primary" style="flex: 1;">üÜï New</button>
            </div>
        </div>
        
        <div class="main-scene">
            <div class="scene-image" id="sceneImage">
                üåü Welcome, Brave Adventurer! üåü
                <div class="scene-overlay">
                    <strong>Current Location:</strong> <span id="currentLocation">The Crossroads Inn</span><br>
                    <strong>Atmosphere:</strong> <span id="currentAtmosphere">A warm, inviting tavern where adventures begin</span>
                </div>
            </div>
            
            <div class="narrative-text" id="narrative">
                <div class="message-dm">
                    <strong>üßô‚Äç‚ôÇÔ∏è Dungeon Master:</strong> Welcome, noble adventurer! The flickering candlelight dances across weathered tavern tables as you step into the Crossroads Inn. 
                    The scent of ale and roasted meat fills the air, while hushed conversations speak of distant lands and forgotten treasures. 
                    Your epic journey awaits... What kind of hero are you, and what destiny calls to your soul?
                </div>
            </div>
            
            <div class="status-bar hidden" id="statusBar"></div>
        </div>
        
        <div class="battle-map">
            <h3>‚öîÔ∏è Battle Map</h3>
            <div class="battle-grid" id="battleGrid">
                <div class="game-piece player-piece" id="player1" style="left: 25px; top: 25px;" title="You - Adventurer" data-name="Hero">H</div>
            </div>
            
            <div style="font-size: 13px; margin: 15px 0; color: #f4e4bc;">
                <strong>Initiative Order:</strong><br>
                <div id="initiativeOrder">
                    <small>‚Ä¢ Your Hero - Ready for battle!</small>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin: 10px 0;">
                <button onclick="rollDice(20)" class="btn-secondary">üé≤ d20</button>
                <button onclick="rollDice(12)" class="btn-info">üé≤ d12</button>
                <button onclick="rollDice(10)" class="btn-info">üé≤ d10</button>
                <button onclick="rollDice(8)" class="btn-info">üé≤ d8</button>
                <button onclick="rollDice(6)" class="btn-info">üé≤ d6</button>
                <button onclick="rollDice(4)" class="btn-info">üé≤ d4</button>
            </div>
            <div style="display: flex; gap: 8px; margin-top: 12px;">
                <button onclick="toggleBattleMode()" class="btn-primary" style="flex: 1;">‚öîÔ∏è Battle</button>
                <button onclick="cycleBattleMap()" class="btn-secondary" style="flex: 1;">üó∫Ô∏è Map</button>
            </div>
        </div>
        
        <div class="controls">
            <button class="voice-button idle" id="voiceBtn" onclick="toggleVoice()">
                üé§ Speak to Dungeon Master
            </button>
            
            <textarea id="manualInput" placeholder="Or inscribe your words here, brave adventurer..." rows="3" style="margin: 10px 0;"></textarea>
            <button onclick="sendManualMessage()" class="btn-secondary" style="width: 100%;">üìú Send Message</button>
            
            <div style="margin-top: 20px; font-size: 12px; color: #c9b037; text-align: center;" id="gameStatus">
                <strong>Campaign:</strong> <span id="sessionDisplay">New Epic Tale</span><br>
                <strong>Status:</strong> <span id="currentStatus">Ready to embark on your legendary quest!</span><br>
                <strong>Chapter:</strong> <span id="turnCounter">1</span>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let recognition;
        let speechSynthesis = window.speechSynthesis;
        let isListening = false;
        let isSpeaking = false;
        let lastResponse = '';
        let sessionId = 'session_' + Date.now();
        let currentBattleMode = false;
        let currentBattleMap = 'tavern';
        let turnCounter = 1;
        let gameHistory = [];
        let draggedPiece = null;
        let dragOffset = { x: 0, y: 0 };
        let atmosphericEffectInterval = null;
        let autoSyncInterval = null;

        // World database for tracking everything
        let worldDatabase = {
            characters: [],
            locations: [],
            items: [],
            events: [],
            quests: [],
            relationships: {},
            reputation: {},
            notes: [],
            gameHistory: [],
            currentLocation: "The Crossroads Inn",
            playerStats: {
                level: 1,
                experience: 0,
                health: 100
            }
        };

        // Battle map configurations with medieval themes
        const battleMapConfigs = {
            tavern: {
                name: 'üç∫ Cozy Tavern Hall',
                background: `
                    radial-gradient(circle at 30% 30%, rgba(160, 82, 45, 0.4) 0%, transparent 30%),
                    radial-gradient(circle at 70% 70%, rgba(139, 69, 19, 0.3) 0%, transparent 25%),
                    linear-gradient(90deg, #654321 1px, transparent 1px),
                    linear-gradient(#654321 1px, transparent 1px),
                    linear-gradient(135deg, #8b4513 0%, #a0522d 100%)
                `,
                description: 'Warm hearth light flickers across wooden floors'
            },
            forest: {
                name: 'üå≤ Enchanted Forest',
                background: `
                    radial-gradient(circle at 25% 40%, rgba(34, 139, 34, 0.6) 0%, transparent 40%),
                    radial-gradient(circle at 75% 60%, rgba(46, 125, 50, 0.4) 0%, transparent 30%),
                    linear-gradient(90deg, #2d5016 1px, transparent 1px),
                    linear-gradient(#2d5016 1px, transparent 1px),
                    linear-gradient(135deg, #2d5016 0%, #4a7c59 100%)
                `,
                description: 'Ancient trees whisper secrets in the moonlight'
            },
            dungeon: {
                name: 'üèõÔ∏è Ancient Dungeon',
                background: `
                    radial-gradient(circle at 50% 20%, rgba(105, 105, 105, 0.4) 0%, transparent 35%),
                    radial-gradient(circle at 20% 80%, rgba(70, 70, 70, 0.3) 0%, transparent 25%),
                    linear-gradient(90deg, #2c2c2c 1px, transparent 1px),
                    linear-gradient(#2c2c2c 1px, transparent 1px),
                    linear-gradient(135deg, #2c2c2c 0%, #4a4a4a 100%)
                `,
                description: 'Cold stone walls echo with ancient mysteries'
            },
            castle: {
                name: 'üè∞ Royal Castle',
                background: `
                    radial-gradient(circle at 40% 30%, rgba(70, 130, 180, 0.4) 0%, transparent 35%),
                    radial-gradient(circle at 80% 70%, rgba(100, 149, 237, 0.3) 0%, transparent 30%),
                    linear-gradient(90deg, #4682b4 1px, transparent 1px),
                    linear-gradient(#4682b4 1px, transparent 1px),
                    linear-gradient(135deg, #4682b4 0%, #6495ed 100%)
                `,
                description: 'Majestic halls where nobles once held court'
            }
        };

        // Settings Modal Functions
        function openSettings() {
            document.getElementById('settingsModal').style.display = 'block';
        }

        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function saveAndCloseSettings() {
            saveApiKeys();
            closeSettings();
            addSystemMessage('‚öôÔ∏è Settings saved! Your adventure continues...');
        }

        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target === modal) {
                closeSettings();
            }
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initSpeechRecognition();
            loadApiKeys();
            setupBattleMapDragging();
            setupKeyboardShortcuts();
            updateSessionDisplay();
            
            // Initialize connection status
            const statusDiv = document.getElementById('connectionStatus');
            statusDiv.innerHTML = '<span class="connection-indicator disconnected"></span>AI: ‚ùå | Cloud: ‚ùå';
            
            // Check for saved game state
            if (localStorage.getItem('dndGameState')) {
                addSystemMessage('üîÑ Previous adventure found! Open Settings and click Load to continue your epic tale.');
            }

            // Start atmospheric effects
            startAtmosphericEffects();
            
            // Enable auto-sync
            enableAutoSync();
            
            console.log('üé≤ Epic Voice D&D Adventure - Fully Loaded! üé≤');
            console.log('‚ú® May your rolls be high and your adventures legendary! ‚ú®');
        });

        // Speech Recognition Setup
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                
                recognition.onstart = function() {
                    isListening = true;
                    updateStatusBar('üé§ The DM listens intently...', 'listening');
                    updateVoiceButton('listening');
                };
                
                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    addUserMessage(transcript);
                    sendToDM(transcript);
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    updateStatusBar('‚ùå The magical voice spell faltered: ' + event.error, 'error');
                    stopListening();
                };
                
                recognition.onend = function() {
                    stopListening();
                };
            } else {
                console.warn('Speech recognition not supported in this browser');
                addSystemMessage('‚ö†Ô∏è Voice magic unavailable in this realm. You can still inscribe messages!');
            }
        }

        // Voice control functions
        function toggleVoice() {
            if (isSpeaking) {
                stopSpeaking();
                return;
            }
            
            if (!isListening) {
                startListening();
            } else {
                stopListening();
            }
        }

        function startListening() {
            if (!document.getElementById('openaiKey').value) {
                addSystemMessage('‚ö†Ô∏è Your magical connection to the AI Dungeon Master requires an API key! Open Settings to configure.');
                return;
            }
            
            if (recognition && !isListening && !isSpeaking) {
                try {
                    recognition.start();
                } catch (error) {
                    console.error('Recognition start error:', error);
                    addSystemMessage('‚ùå The voice enchantment failed to activate. Please try again.');
                }
            }
        }

        function stopListening() {
            if (recognition && isListening) {
                recognition.stop();
            }
            isListening = false;
            updateVoiceButton('idle');
            hideStatusBar();
        }

        function updateVoiceButton(state) {
            const btn = document.getElementById('voiceBtn');
            btn.className = `voice-button ${state}`;
            
            switch(state) {
                case 'listening':
                    btn.textContent = 'üõë Stop Listening';
                    break;
                case 'speaking':
                    btn.textContent = 'üîä DM Speaking... (click to stop)';
                    break;
                default:
                    btn.textContent = 'üé§ Speak to Dungeon Master';
            }
        }

        // Text-to-Speech functions
        async function speakResponse(text) {
            if (!document.getElementById('enableVoice').checked) return;

            const elevenLabsKey = document.getElementById('elevenLabsKey').value;
            const voiceId = document.getElementById('elevenLabsVoice').value;
            
            if (elevenLabsKey && voiceId) {
                await speakWithElevenLabs(text, elevenLabsKey, voiceId);
            } else {
                speakWithBrowser(text);
            }
        }

        async function speakWithElevenLabs(text, apiKey, voiceId) {
            isSpeaking = true;
            updateVoiceButton('speaking');
            updateStatusBar('üó£Ô∏è The Dungeon Master speaks with ancient wisdom...', 'speaking');
            
            try {
                const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
                    method: 'POST',
                    headers: {
                        'Accept': 'audio/mpeg',
                        'Content-Type': 'application/json',
                        'xi-api-key': apiKey
                    },
                    body: JSON.stringify({
                        text: text.replace(/\*.*?\*/g, ''), // Remove action text
                        model_id: 'eleven_monolingual_v1',
                        voice_settings: {
                            stability: 0.5,
                            similarity_boost: 0.5
                        }
                    })
                });

                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audio = new Audio(URL.createObjectURL(audioBlob));
                    
                    audio.onended = () => {
                        isSpeaking = false;
                        updateVoiceButton('idle');
                        hideStatusBar();
                    };
                    
                    await audio.play();
                } else {
                    throw new Error('ElevenLabs API error: ' + response.status);
                }
            } catch (error) {
                console.error('ElevenLabs TTS error:', error);
                speakWithBrowser(text); // Fallback to browser TTS
            }
        }

        function speakWithBrowser(text) {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            isSpeaking = true;
            updateVoiceButton('speaking');
            updateStatusBar('üó£Ô∏è The Dungeon Master speaks...', 'speaking');
            
            const utterance = new SpeechSynthesisUtterance(text.replace(/\*.*?\*/g, ''));
            utterance.rate = 0.9;
            utterance.pitch = 1.0;
            utterance.volume = 0.8;
            
            utterance.onend = () => {
                isSpeaking = false;
                updateVoiceButton('idle');
                hideStatusBar();
            };
            
            utterance.onerror = () => {
                isSpeaking = false;
                updateVoiceButton('idle');
                hideStatusBar();
            };
            
            speechSynthesis.speak(utterance);
        }

        function stopSpeaking() {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            isSpeaking = false;
            updateVoiceButton('idle');
            hideStatusBar();
        }

        // Status bar functions
        function updateStatusBar(message, type) {
            const statusBar = document.getElementById('statusBar');
            statusBar.textContent = message;
            statusBar.className = `status-bar ${type}`;
            statusBar.classList.remove('hidden');
        }

        function hideStatusBar() {
            document.getElementById('statusBar').classList.add('hidden');
        }

        // Message handling functions
        function addMessage(sender, message) {
            const narrative = document.getElementById('narrative');
            const messageDiv = document.createElement('div');
            
            if (sender === 'user') {
                messageDiv.className = 'message-user';
                messageDiv.innerHTML = `<strong>üó£Ô∏è You:</strong> ${message}`;
            } else if (sender === 'dm') {
                messageDiv.className = 'message-dm';
                messageDiv.innerHTML = `<strong>üßô‚Äç‚ôÇÔ∏è Dungeon Master:</strong> ${message}`;
            } else {
                messageDiv.className = 'message-system';
                messageDiv.innerHTML = `<strong>üìñ Chronicle:</strong> ${message}`;
            }
            
            narrative.appendChild(messageDiv);
            narrative.scrollTop = narrative.scrollHeight;
            
            // Store in game history
            gameHistory.push({
                timestamp: new Date().toISOString(),
                sender: sender,
                message: message,
                turn: turnCounter
            });
            
            updateGameStatus();
            updateWorldDisplay();
            
            // Easter eggs for user messages
            if (sender === 'user') {
                addEasterEgg(message);
            }
            
            // Auto-sync to database if enabled
            if (document.getElementById('autoSync') && document.getElementById('autoSync').checked) {
                const gameState = {
                    worldDatabase: worldDatabase,
                    gameHistory: gameHistory,
                    sessionId: sessionId,
                    turnCounter: turnCounter,
                    currentBattleMode: currentBattleMode,
                    currentBattleMap: currentBattleMap,
                    timestamp: new Date().toISOString()
                };
                syncToDatabase(gameState).catch(error => console.error('Auto-sync failed:', error));
            }
        }

        // Convenience functions for different message types
        function addUserMessage(message) {
            addMessage('user', message);
        }

        function addDMMessage(message) {
            addMessage('dm', message);
        }

        function addSystemMessage(message) {
            addMessage('system', message);
        }

        function sendManualMessage() {
            const input = document.getElementById('manualInput');
            const message = input.value.trim();
            if (message) {
                addUserMessage(message);
                sendToDM(message);
                input.value = '';
            }
        }

        // Main DM communication
        async function sendToDM(message) {
            updateStatusBar('ü§î The Dungeon Master contemplates your words...', 'processing');
            turnCounter++;
            
            const apiKey = document.getElementById('openaiKey').value;
            if (!apiKey) {
                addSystemMessage('‚ùå The magical connection to your AI Dungeon Master is severed! Open Settings and add your OpenAI API key.');
                hideStatusBar();
                return;
            }
            
            // Build context from game history and world state
            const context = buildGameContext();
            
            const prompt = `You are a masterful D&D Dungeon Master running an immersive medieval fantasy campaign. The player says: "${message}"

Current Context:
${context}

Instructions:
- Respond as an expert DM would, creating vivid, engaging fantasy narrative
- Use rich medieval/fantasy descriptions and atmosphere
- Keep responses under 150 words for voice interaction
- Remember all ongoing story elements and character relationships
- When you introduce NEW elements, format them exactly like this:

[NEW_CHARACTER: Name | Role/Type | Brief Description]
[NEW_LOCATION: Name | Type | Brief Description] 
[NEW_QUEST: Name | Status | Description | Objective]
[NEW_NOTE: Important lore, clue, or detail to remember]

Examples:
[NEW_CHARACTER: Sir Aldrich the Bold | Knight Commander | A weathered veteran with scars and honor]
[NEW_LOCATION: The Whispering Caverns | Ancient Cave System | Echoing depths where shadows move]
[NEW_QUEST: The Lost Crown of Kings | Active | Ancient crown stolen by bandits | Recover the crown from the Shadowmere Bandits]
[NEW_NOTE: The mysterious runes glow crimson when touched by noble blood]

Create an immersive, exciting fantasy adventure that brings the medieval world to life!`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4',
                        messages: [{ role: 'user', content: prompt }],
                        temperature: 0.8,
                        max_tokens: 250
                    })
                });

                const data = await response.json();
                if (data.error) {
                    throw new Error(data.error.message);
                }
                
                const dmResponse = data.choices[0].message.content;
                lastResponse = dmResponse;
                
                // Extract and process world elements
                extractWorldData(dmResponse);
                
                // Clean response for display (remove the formatting tags)
                const cleanResponse = dmResponse
                    .replace(/\[NEW_CHARACTER:[^\]]+\]/g, '')
                    .replace(/\[NEW_LOCATION:[^\]]+\]/g, '')
                    .replace(/\[NEW_QUEST:[^\]]+\]/g, '')
                    .replace(/\[NEW_NOTE:[^\]]+\]/g, '')
                    .trim();
                
                addDMMessage(cleanResponse);
                
                // Speak the response
                await speakResponse(cleanResponse);
                
                updateStatusBar('‚ú® Your tale continues...', 'success');
                setTimeout(hideStatusBar, 3000);
                
            } catch (error) {
                console.error('OpenAI API error:', error);
                addDMMessage(`‚ùå The magical connection faltered: ${error.message}`);
                updateStatusBar('‚ùå Connection to the realm failed', 'error');
                setTimeout(hideStatusBar, 3000);
            }
        }

        function buildGameContext() {
            let context = `Current Location: ${worldDatabase.currentLocation}\n`;
            
            if (worldDatabase.characters.length > 0) {
                context += `Known Characters: ${worldDatabase.characters.map(c => c.name).join(', ')}\n`;
            }
            
            if (worldDatabase.quests.length > 0) {
                const activeQuests = worldDatabase.quests.filter(q => q.status === 'active');
                if (activeQuests.length > 0) {
                    context += `Active Quests: ${activeQuests.map(q => q.name).join(', ')}\n`;
                }
            }
            
            if (worldDatabase.notes.length > 0) {
                context += `Important Lore: ${worldDatabase.notes.slice(-3).join('; ')}\n`;
            }
            
            // Add recent history context
            const recentHistory = gameHistory.slice(-6).map(h => `${h.sender}: ${h.message}`).join('\n');
            if (recentHistory) {
                context += `Recent events:\n${recentHistory}\n`;
            }
            
            return context;
        }

        // World data extraction and management
        function extractWorldData(response) {
            // Extract characters
            const characterMatches = response.match(/\[NEW_CHARACTER: ([^|]+)\|([^|]+)\|([^\]]+)\]/g);
            if (characterMatches) {
                characterMatches.forEach(match => {
                    const parts = match.match(/\[NEW_CHARACTER: ([^|]+)\|([^|]+)\|([^\]]+)\]/);
                    if (parts) {
                        const character = {
                            id: Date.now() + Math.random(),
                            name: parts[1].trim(),
                            role: parts[2].trim(),
                            description: parts[3].trim(),
                            discovered: new Date().toLocaleString(),
                            relationship: 'neutral'
                        };
                        worldDatabase.characters.push(character);
                        addSystemMessage(`üÜï New character encountered: ${character.name} (${character.role})`);
                    }
                });
            }
            
            // Extract locations
            const locationMatches = response.match(/\[NEW_LOCATION: ([^|]+)\|([^|]+)\|([^\]]+)\]/g);
            if (locationMatches) {
                locationMatches.forEach(match => {
                    const parts = match.match(/\[NEW_LOCATION: ([^|]+)\|([^|]+)\|([^\]]+)\]/);
                    if (parts) {
                        const location = {
                            id: Date.now() + Math.random(),
                            name: parts[1].trim(),
                            type: parts[2].trim(),
                            description: parts[3].trim(),
                            discovered: new Date().toLocaleString()
                        };
                        worldDatabase.locations.push(location);
                        worldDatabase.currentLocation = location.name;
                        addSystemMessage(`üó∫Ô∏è New location discovered: ${location.name}`);
                        updateSceneVisuals(location.name, location.description);
                    }
                });
            }
            
            // Extract quests
            const questMatches = response.match(/\[NEW_QUEST: ([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/g);
            if (questMatches) {
                questMatches.forEach(match => {
                    const parts = match.match(/\[NEW_QUEST: ([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/);
                    if (parts) {
                        const quest = {
                            id: Date.now() + Math.random(),
                            name: parts[1].trim(),
                            status: parts[2].trim().toLowerCase(),
                            description: parts[3].trim(),
                            objective: parts[4].trim(),
                            started: new Date().toLocaleString(),
                            updates: []
                        };
                        worldDatabase.quests.push(quest);
                        addSystemMessage(`üìú New quest received: ${quest.name} (${quest.status})`);
                    }
                });
            }
            
            // Extract notes
            const noteMatches = response.match(/\[NEW_NOTE: ([^\]]+)\]/g);
            if (noteMatches) {
                noteMatches.forEach(match => {
                    const parts = match.match(/\[NEW_NOTE: ([^\]]+)\]/);
                    if (parts) {
                        const note = parts[1].trim();
                        worldDatabase.notes.push(note);
                        addSystemMessage(`üìù Important lore recorded: ${note}`);
                    }
                });
            }
            
            updateWorldDisplay();
        }

        function updateSceneVisuals(location, description) {
            const sceneImage = document.getElementById('sceneImage');
            const currentLocationSpan = document.getElementById('currentLocation');
            const currentAtmosphereSpan = document.getElementById('currentAtmosphere');
            
            if (location) {
                currentLocationSpan.textContent = location;
            }
            if (description) {
                currentAtmosphereSpan.textContent = description;
            }
            
            // Update scene background based on location
            const locationLower = (location || '').toLowerCase();
            const sceneOverlay = sceneImage.querySelector('.scene-overlay');
            
            if (locationLower.includes('forest') || locationLower.includes('wood') || locationLower.includes('grove')) {
                sceneImage.style.background = 'linear-gradient(45deg, #2d5016, #4a7c59)';
                sceneImage.innerHTML = 'üå≤ ' + (location || 'Enchanted Forest') + ' üå≤';
                sceneImage.appendChild(sceneOverlay);
            } else if (locationLower.includes('tavern') || locationLower.includes('inn') || locationLower.includes('pub')) {
                sceneImage.style.background = 'linear-gradient(45deg, #8b4513, #cd853f)';
                sceneImage.innerHTML = 'üç∫ ' + (location || 'Tavern') + ' üç∫';
                sceneImage.appendChild(sceneOverlay);
            } else if (locationLower.includes('dungeon') || locationLower.includes('cave') || locationLower.includes('tomb') || locationLower.includes('crypt')) {
                sceneImage.style.background = 'linear-gradient(45deg, #2c2c2c, #4a4a4a)';
                sceneImage.innerHTML = 'üèõÔ∏è ' + (location || 'Ancient Dungeon') + ' üèõÔ∏è';
                sceneImage.appendChild(sceneOverlay);
            } else if (locationLower.includes('city') || locationLower.includes('town') || locationLower.includes('village')) {
                sceneImage.style.background = 'linear-gradient(45deg, #4682b4, #87ceeb)';
                sceneImage.innerHTML = 'üèòÔ∏è ' + (location || 'Village') + ' üèòÔ∏è';
                sceneImage.appendChild(sceneOverlay);
            } else if (locationLower.includes('castle') || locationLower.includes('palace') || locationLower.includes('fortress')) {
                sceneImage.style.background = 'linear-gradient(45deg, #4682b4, #6495ed)';
                sceneImage.innerHTML = 'üè∞ ' + (location || 'Royal Castle') + ' üè∞';
                sceneImage.appendChild(sceneOverlay);
            } else if (locationLower.includes('mountain') || locationLower.includes('peak') || locationLower.includes('cliff')) {
                sceneImage.style.background = 'linear-gradient(45deg, #696969, #a9a9a9)';
                sceneImage.innerHTML = 'üèîÔ∏è ' + (location || 'Mountain Peak') + ' üèîÔ∏è';
                sceneImage.appendChild(sceneOverlay);
            }
        }

        function updateWorldDisplay() {
            // Update active quests
            const activeQuestsDiv = document.getElementById('activeQuests');
            const activeQuests = worldDatabase.quests.filter(q => q.status === 'active');
            if (activeQuests.length > 0) {
                activeQuestsDiv.innerHTML = activeQuests.map(quest => 
                    `<small>‚Ä¢ <strong>${quest.name}</strong><br>&nbsp;&nbsp;<em>${quest.objective}</em></small>`
                ).join('<br>');
            } else {
                activeQuestsDiv.innerHTML = '<em>No active quests discovered yet</em>';
            }
            
            // Update known characters
            const charactersDiv = document.getElementById('knownCharacters');
            if (worldDatabase.characters.length > 0) {
                charactersDiv.innerHTML = worldDatabase.characters.slice(-5).map(char => 
                    `<small>‚Ä¢ <strong>${char.name}</strong> (${char.role})<br>&nbsp;&nbsp;<em>${char.description}</em></small>`
                ).join('<br>');
            } else {
                charactersDiv.innerHTML = '<em>No characters met yet</em>';
            }
            
            // Update known locations
            const locationsDiv = document.getElementById('knownLocations');
            if (worldDatabase.locations.length > 0) {
                locationsDiv.innerHTML = worldDatabase.locations.slice(-5).map(loc => 
                    `<small>‚Ä¢ <strong>${loc.name}</strong> (${loc.type})<br>&nbsp;&nbsp;<em>${loc.description}</em></small>`
                ).join('<br>');
            } else {
                locationsDiv.innerHTML = '<em>No locations discovered yet</em>';
            }
            
            // Update important notes
            const notesDiv = document.getElementById('importantNotes');
            if (worldDatabase.notes.length > 0) {
                notesDiv.innerHTML = worldDatabase.notes.slice(-5).map(note => 
                    `<small>‚Ä¢ ${note}</small>`
                ).join('<br>');
            } else {
                notesDiv.innerHTML = '<em>No lore recorded yet</em>';
            }
        }

        // Dice rolling functions
        function rollDice(sides = 20) {
            const roll = Math.floor(Math.random() * sides) + 1;
            let diceEmoji = 'üé≤';
            let message = '';
            let flavor = '';
            
            if (sides === 20) {
                if (roll === 20) {
                    diceEmoji = 'üéØ';
                    message = `Natural 20! Critical Success!`;
                    flavor = '‚ú® The dice blazes with divine favor!';
                } else if (roll === 1) {
                    diceEmoji = 'üí•';
                    message = `Natural 1! Critical Failure!`;
                    flavor = 'üò∞ The dice are cursed by mischievous fey...';
                } else if (roll >= 17) {
                    message = `You rolled a mighty ${roll}!`;
                    flavor = '‚≠ê Fortune smiles upon you!';
                } else if (roll <= 4) {
                    message = `You rolled a disappointing ${roll}`;
                    flavor = 'üíÄ The fates seem against you...';
                } else {
                    message = `You rolled a ${roll}`;
                }
            } else {
                message = `You rolled a ${roll} on a d${sides}`;
                if (roll === sides) {
                    flavor = 'üåü Maximum result achieved!';
                }
            }
            
            addSystemMessage(`${diceEmoji} <span class="dice-result">${roll}</span> ${message}`);
            if (flavor) {
                addSystemMessage(flavor);
            }
        }

        // Battle map functions
        function toggleBattleMode() {
            currentBattleMode = !currentBattleMode;
            const battleGrid = document.getElementById('battleGrid');
            
            if (currentBattleMode) {
                battleGrid.style.border = '3px solid #dc143c';
                battleGrid.style.animation = 'battlePulse 2s ease-in-out infinite alternate';
                addSystemMessage('‚öîÔ∏è Battle mode activated! Roll for initiative!');
                rollInitiative();
            } else {
                battleGrid.style.border = '3px solid #8b4513';
                battleGrid.style.animation = 'none';
                battleGrid.style.boxShadow = '0 4px 20px rgba(0, 0, 0, 0.6), inset 0 2px 4px rgba(139, 69, 19, 0.3)';
                addSystemMessage('üïäÔ∏è Combat ended. You may rest and recover.');
            }
        }

        function cycleBattleMap() {
            const mapTypes = ['tavern', 'forest', 'dungeon', 'castle'];
            const currentIndex = mapTypes.indexOf(currentBattleMap);
            const nextIndex = (currentIndex + 1) % mapTypes.length;
            currentBattleMap = mapTypes[nextIndex];
            
            const battleGrid = document.getElementById('battleGrid');
            const config = battleMapConfigs[currentBattleMap];
            
            battleGrid.style.background = config.background;
            battleGrid.style.backgroundSize = '50px 50px, 50px 50px, 25px 25px, 25px 25px, 100% 100%';
            
            addSystemMessage(`üó∫Ô∏è Map changed to: ${config.name} - ${config.description}`);
        }

        function rollInitiative() {
            const playerRoll = Math.floor(Math.random() * 20) + 1;
            const enemyRoll = Math.floor(Math.random() * 20) + 1;
            
            const initiativeDiv = document.getElementById('initiativeOrder');
            
            if (playerRoll >= enemyRoll) {
                initiativeDiv.innerHTML = `
                    <small>‚Ä¢ <strong>Your Hero</strong> - ${playerRoll} (Your turn!)</small><br>
                    <small>‚Ä¢ Enemy Forces - ${enemyRoll} (Waiting...)</small>
                `;
            } else {
                initiativeDiv.innerHTML = `
                    <small>‚Ä¢ Enemy Forces - ${enemyRoll} (Their turn!)</small><br>
                    <small>‚Ä¢ <strong>Your Hero</strong> - ${playerRoll} (Prepare yourself...)</small>
                `;
            }
        }

        // Battle map dragging functionality
        function setupBattleMapDragging() {
            const battleGrid = document.getElementById('battleGrid');
            
            battleGrid.addEventListener('mousedown', startDrag);
            battleGrid.addEventListener('mousemove', drag);
            battleGrid.addEventListener('mouseup', endDrag);
            battleGrid.addEventListener('mouseleave', endDrag);
            
            // Touch events for mobile
            battleGrid.addEventListener('touchstart', startDrag);
            battleGrid.addEventListener('touchmove', drag);
            battleGrid.addEventListener('touchend', endDrag);

            // Context menu for game pieces
            battleGrid.addEventListener('contextmenu', function(e) {
                if (e.target.classList.contains('game-piece')) {
                    e.preventDefault();
                    
                    const pieceName = e.target.dataset.name || 'Unknown';
                    const options = [
                        'üó°Ô∏è Attack',
                        'üõ°Ô∏è Defend', 
                        'üèÉ Move',
                        'üéØ Cast Spell',
                        'üíä Use Item'
                    ];
                    
                    const action = options[Math.floor(Math.random() * options.length)];
                    addSystemMessage(`${pieceName} prepares to: ${action}`);
                    
                    // Add visual feedback
                    e.target.style.transform = 'scale(1.5)';
                    setTimeout(() => {
                        e.target.style.transform = 'scale(1)';
                    }, 300);
                }
            });
        }

        function startDrag(e) {
            e.preventDefault();
            const target = e.target.closest('.game-piece');
            if (!target) return;
            
            draggedPiece = target;
            const rect = target.getBoundingClientRect();
            const gridRect = document.getElementById('battleGrid').getBoundingClientRect();
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            dragOffset.x = clientX - rect.left;
            dragOffset.y = clientY - rect.top;
            
            target.style.zIndex = '1000';
            target.style.cursor = 'grabbing';
        }

        function drag(e) {
            if (!draggedPiece) return;
            e.preventDefault();
            
            const gridRect = document.getElementById('battleGrid').getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            let newX = clientX - gridRect.left - dragOffset.x;
            let newY = clientY - gridRect.top - dragOffset.y;
            
            // Snap to grid (25px grid)
            newX = Math.round(newX / 25) * 25;
            newY = Math.round(newY / 25) * 25;
            
            // Keep within bounds
            newX = Math.max(0, Math.min(newX, gridRect.width - 25));
            newY = Math.max(0, Math.min(newY, gridRect.height - 25));
            
            draggedPiece.style.left = newX + 'px';
            draggedPiece.style.top = newY + 'px';
        }

        function endDrag() {
            if (draggedPiece) {
                draggedPiece.style.zIndex = 'auto';
                draggedPiece.style.cursor = 'grab';
                
                // Convert position to grid coordinates for feedback
                const x = Math.round(parseInt(draggedPiece.style.left) / 25);
                const y = Math.round(parseInt(draggedPiece.style.top) / 25);
                
                if (draggedPiece.dataset.name) {
                    addSystemMessage(`üìç ${draggedPiece.dataset.name} moved to position (${x}, ${y}) on the battlefield`);
                }
                
                draggedPiece = null;
            }
        }

        // Game state management
        async function saveGameState() {
            const gameState = {
                worldDatabase: worldDatabase,
                gameHistory: gameHistory,
                sessionId: sessionId,
                turnCounter: turnCounter,
                currentBattleMode: currentBattleMode,
                currentBattleMap: currentBattleMap,
                timestamp: new Date().toISOString()
            };
            
            try {
                // Always save locally first
                localStorage.setItem('dndGameState', JSON.stringify(gameState));
                addSystemMessage('üíæ Your epic tale has been chronicled!');
                
                // Try to sync to external database if configured
                const autoSync = document.getElementById('autoSync');
                if (autoSync && autoSync.checked) {
                    updateStatusBar('‚òÅÔ∏è Syncing your adventure to the cloud...', 'processing');
                    const synced = await syncToDatabase(gameState);
                    if (synced) {
                        addSystemMessage('‚òÅÔ∏è Adventure also saved to the cloud realm!');
                    }
                    hideStatusBar();
                }
                
                updateSessionDisplay();
            } catch (error) {
                addSystemMessage('‚ùå Failed to chronicle your adventure: ' + error.message);
            }
        }

        async function loadGameState() {
            let gameState = null;
            
            // Try to load from external database first
            const backendUrl = document.getElementById('backendUrl').value;
            if (backendUrl) {
                updateStatusBar('‚òÅÔ∏è Loading your saga from the cloud...', 'processing');
                gameState = await loadFromDatabase();
                if (gameState) {
                    addSystemMessage('‚òÅÔ∏è Your legendary tale restored from the cloud!');
                }
                hideStatusBar();
            }
            
            // Fall back to local storage if database load failed
            if (!gameState) {
                try {
                    const savedState = localStorage.getItem('dndGameState');
                    if (savedState) {
                        gameState = JSON.parse(savedState);
                        addSystemMessage('üìÇ Your adventure restored from the chronicles!');
                    }
                } catch (error) {
                    console.error('Local storage load error:', error);
                }
            }
            
            if (!gameState) {
                addSystemMessage('üìÇ No saved adventures found in the archives.');
                return;
            }
            
            try {
                worldDatabase = gameState.worldDatabase || worldDatabase;
                gameHistory = gameState.gameHistory || [];
                turnCounter = gameState.turnCounter || 1;
                currentBattleMode = gameState.currentBattleMode || false;
                currentBattleMap = gameState.currentBattleMap || 'tavern';
                
                // Restore UI state
                updateWorldDisplay();
                updateSceneVisuals(worldDatabase.currentLocation, 'Your legendary adventure continues...');
                
                // Set the correct battle map
                const battleGrid = document.getElementById('battleGrid');
                const config = battleMapConfigs[currentBattleMap];
                battleGrid.style.background = config.background;
                battleGrid.style.backgroundSize = '50px 50px, 50px 50px, 25px 25px, 25px 25px, 100% 100%';
                
                updateSessionDisplay();
                
                // Restore some conversation history
                const narrative = document.getElementById('narrative');
                narrative.innerHTML = '<div class="message-dm"><strong>üßô‚Äç‚ôÇÔ∏è DM:</strong> Welcome back, brave hero! The flames of adventure still burn bright in your eyes. Your legend continues where it left off...</div>';
                
                if (gameHistory.length > 0) {
                    const recentHistory = gameHistory.slice(-3);
                    recentHistory.forEach(entry => {
                        addMessage(entry.sender, entry.message);
                    });
                }
                
                addSystemMessage('‚úÖ Your epic tale resumes! What legendary deeds await?');
                
            } catch (error) {
                addSystemMessage('‚ùå Failed to restore your adventure: ' + error.message);
            }
        }

        function newGame() {
            if (confirm('Are you sure you want to begin a new adventure? This will erase your current legend.')) {
                // Reset everything
                worldDatabase = {
                    characters: [],
                    locations: [],
                    items: [],
                    events: [],
                    quests: [],
                    relationships: {},
                    reputation: {},
                    notes: [],
                    gameHistory: [],
                    currentLocation: "The Crossroads Inn",
                    playerStats: { level: 1, experience: 0, health: 100 }
                };
                
                gameHistory = [];
                turnCounter = 1;
                sessionId = 'session_' + Date.now();
                currentBattleMode = false;
                currentBattleMap = 'tavern';
                
                // Reset UI
                const narrative = document.getElementById('narrative');
                narrative.innerHTML = `
                    <div class="message-dm">
                        <strong>üßô‚Äç‚ôÇÔ∏è Dungeon Master:</strong> Welcome, noble adventurer! The flickering candlelight dances across weathered tavern tables as you step into the Crossroads Inn. 
                        The scent of ale and roasted meat fills the air, while hushed conversations speak of distant lands and forgotten treasures. 
                        Your epic journey awaits... What kind of hero are you, and what destiny calls to your soul?
                    </div>
                `;
                
                updateWorldDisplay();
                updateSceneVisuals('The Crossroads Inn', 'A warm, inviting tavern where adventures begin');
                updateSessionDisplay();
                
                // Clear localStorage
                localStorage.removeItem('dndGameState');
                
                addSystemMessage('üÜï A new legend begins! What kind of hero will you become?');
            }
        }

        // API Key management
        function saveApiKeys() {
            const openaiKey = document.getElementById('openaiKey').value;
            const elevenLabsKey = document.getElementById('elevenLabsKey').value;
            const voice = document.getElementById('elevenLabsVoice').value;
            const backendUrl = document.getElementById('backendUrl').value;
            
            if (openaiKey) {
                localStorage.setItem('openai_api_key', openaiKey);
            }
            if (elevenLabsKey) {
                localStorage.setItem('elevenlabs_api_key', elevenLabsKey);
            }
            if (voice) {
                localStorage.setItem('elevenlabs_voice', voice);
            }
            if (backendUrl) {
                localStorage.setItem('backend_url', backendUrl);
            }
            
            addSystemMessage('üîê Your magical keys have been securely stored!');
            
            // Test connections after a brief delay
            setTimeout(() => {
                if (openaiKey) testConnection();
                if (backendUrl) testBackendConnection();
            }, 100);
        }

        function loadApiKeys() {
            const openaiKey = localStorage.getItem('openai_api_key');
            const elevenLabsKey = localStorage.getItem('elevenlabs_api_key');
            const voice = localStorage.getItem('elevenlabs_voice');
            const backendUrl = localStorage.getItem('backend_url');
            
            if (openaiKey) {
                document.getElementById('openaiKey').value = openaiKey;
            }
            if (elevenLabsKey) {
                document.getElementById('elevenLabsKey').value = elevenLabsKey;
            }
            if (voice) {
                document.getElementById('elevenLabsVoice').value = voice;
            }
            if (backendUrl) {
                document.getElementById('backendUrl').value = backendUrl;
            }
            
            // Test connections after a brief delay to let UI update
            setTimeout(() => {
                if (openaiKey) {
                    testConnection();
                }
                if (backendUrl) {
                    testBackendConnection();
                }
            }, 100);
        }

        function clearApiKeys() {
            if (confirm('Are you sure you want to clear all saved magical keys?')) {
                localStorage.removeItem('openai_api_key');
                localStorage.removeItem('elevenlabs_api_key');
                localStorage.removeItem('elevenlabs_voice');
                localStorage.removeItem('backend_url');
                
                document.getElementById('openaiKey').value = '';
                document.getElementById('elevenLabsKey').value = '';
                document.getElementById('elevenLabsVoice').value = '';
                document.getElementById('backendUrl').value = '';
                
                // Reset both connection statuses
                const statusDiv = document.getElementById('connectionStatus');
                statusDiv.innerHTML = '<span class="connection-indicator disconnected"></span>AI: ‚ùå | Cloud: ‚ùå';
                
                addSystemMessage('üóëÔ∏è All magical keys have been cleared from the crystal storage.');
            }
        }

        async function testBackendConnection() {
            const backendUrl = document.getElementById('backendUrl').value;
            if (!backendUrl) {
                updateConnectionStatus(false, 'No cloud realm URL provided');
                return;
            }
            
            updateConnectionStatus(null, 'Testing connection to the cloud realm...');
            
            try {
                // First try a simple GET request to test basic connectivity
                console.log('Testing connection to:', backendUrl);
                
                const response = await fetch(backendUrl + '?action=get_world_summary', {
                    method: 'GET',
                    mode: 'cors'
                });
                
                console.log('Response status:', response.status);
                console.log('Response ok:', response.ok);
                
                if (response.ok) {
                    const result = await response.text(); // Get as text first
                    console.log('Response text:', result);
                    
                    try {
                        const jsonResult = JSON.parse(result);
                        if (jsonResult.success !== false) {
                            updateConnectionStatus(true, 'Cloud realm connected via GET');
                            addSystemMessage('‚òÅÔ∏è Connection to the cloud realm established!');
                            return;
                        }
                    } catch (parseError) {
                        console.log('JSON parse error, but connection worked:', parseError);
                        updateConnectionStatus(true, 'Cloud realm reachable');
                        addSystemMessage('‚òÅÔ∏è Cloud realm is reachable! (Adjusting magical protocols...)');
                        return;
                    }
                }
                
                // If GET fails, try POST method
                console.log('GET failed, trying POST method...');
                
                const postResponse = await fetch(backendUrl, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'get_world_data',
                        type: 'characters',
                        sessionId: sessionId
                    })
                });
                
                console.log('POST Response status:', postResponse.status);
                
                if (postResponse.ok) {
                    const result = await postResponse.text();
                    console.log('POST Response text:', result);
                    
                    try {
                        const jsonResult = JSON.parse(result);
                        if (jsonResult.success !== false) {
                            updateConnectionStatus(true, 'Cloud realm connected via POST');
                            addSystemMessage('‚òÅÔ∏è Connection to the cloud realm established!');
                        } else {
                            updateConnectionStatus(false, 'Cloud error: ' + (jsonResult.error || 'Unknown magical interference'));
                        }
                    } catch (parseError) {
                        updateConnectionStatus(true, 'Cloud realm reachable');
                        addSystemMessage('‚òÅÔ∏è Cloud realm is reachable! (Adjusting magical protocols...)');
                    }
                } else {
                    throw new Error(`HTTP Error: ${postResponse.status} ${postResponse.statusText}`);
                }
                
            } catch (error) {
                console.error('Backend connection error details:', error);
                
                if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                    updateConnectionStatus(false, 'Magical barrier (CORS) blocks connection');
                    addSystemMessage('‚ùå Connection blocked by protective enchantments. Check your cloud realm deployment settings.');
                } else if (error.message.includes('HTTP Error')) {
                    updateConnectionStatus(false, error.message);
                    addSystemMessage('‚ùå Cloud realm error: ' + error.message);
                } else {
                    updateConnectionStatus(false, 'Cloud realm unreachable');
                    addSystemMessage('‚ö†Ô∏è Cloud realm not reachable. Using local chronicles only.');
                }
            }
        }

        async function syncToDatabase(data) {
            const backendUrl = document.getElementById('backendUrl').value;
            const autoSync = document.getElementById('autoSync');
            
            if (!backendUrl || !autoSync || !autoSync.checked) return false;
            
            try {
                // Save each type of world data separately to match the Google Apps Script
                const savePromises = [];
                
                // Save characters
                if (data.worldDatabase.characters && data.worldDatabase.characters.length > 0) {
                    for (const character of data.worldDatabase.characters) {
                        savePromises.push(
                            fetch(backendUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'save_world_data',
                                    type: 'characters',
                                    sessionId: sessionId,
                                    payload: character
                                })
                            })
                        );
                    }
                }
                
                // Save locations
                if (data.worldDatabase.locations && data.worldDatabase.locations.length > 0) {
                    for (const location of data.worldDatabase.locations) {
                        savePromises.push(
                            fetch(backendUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'save_world_data',
                                    type: 'locations',
                                    sessionId: sessionId,
                                    payload: location
                                })
                            })
                        );
                    }
                }
                
                // Save quests
                if (data.worldDatabase.quests && data.worldDatabase.quests.length > 0) {
                    for (const quest of data.worldDatabase.quests) {
                        savePromises.push(
                            fetch(backendUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'save_world_data',
                                    type: 'quests',
                                    sessionId: sessionId,
                                    payload: quest
                                })
                            })
                        );
                    }
                }
                
                // Save notes
                if (data.worldDatabase.notes && data.worldDatabase.notes.length > 0) {
                    for (const note of data.worldDatabase.notes) {
                        savePromises.push(
                            fetch(backendUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'save_world_data',
                                    type: 'notes',
                                    sessionId: sessionId,
                                    payload: {
                                        subject: 'Adventure Lore',
                                        note: note,
                                        category: 'gameplay'
                                    }
                                })
                            })
                        );
                    }
                }
                
                // Wait for all saves to complete
                const responses = await Promise.all(savePromises);
                const allSuccessful = responses.every(response => response.ok);
                
                return allSuccessful;
                
            } catch (error) {
                console.error('Database sync error:', error);
                return false;
            }
        }

        async function loadFromDatabase() {
            const backendUrl = document.getElementById('backendUrl').value;
            
            if (!backendUrl) return null;
            
            try {
                // Load all world data from the database
                const response = await fetch(backendUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'get_world_data',
                        type: 'all',
                        sessionId: sessionId
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.data) {
                        // Convert the database format back to our game format
                        const gameState = {
                            worldDatabase: {
                                characters: result.data.characters || [],
                                locations: result.data.locations || [],
                                quests: result.data.quests || [],
                                notes: (result.data.notes || []).map(n => n.note || n.subject),
                                items: [],
                                events: [],
                                relationships: result.data.relationships || {},
                                reputation: {},
                                gameHistory: [],
                                currentLocation: "The Crossroads Inn",
                                playerStats: { level: 1, experience: 0, health: 100 }
                            },
                            gameHistory: [],
                            sessionId: sessionId,
                            turnCounter: 1,
                            currentBattleMode: false,
                            currentBattleMap: 'tavern',
                            timestamp: new Date().toISOString()
                        };
                        
                        return gameState;
                    }
                }
            } catch (error) {
                console.error('Database load error:', error);
            }
            return null;
        }

        async function testConnection() {
            const apiKey = document.getElementById('openaiKey').value;
            if (!apiKey) {
                updateConnectionStatus(false, 'No AI Oracle key provided');
                return;
            }
            
            updateConnectionStatus(null, 'Testing connection to the AI Oracle...');
            
            try {
                const response = await fetch('https://api.openai.com/v1/models', {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });
                
                if (response.ok) {
                    updateConnectionStatus(true, 'AI Oracle connected');
                } else {
                    updateConnectionStatus(false, 'Invalid Oracle key');
                }
            } catch (error) {
                updateConnectionStatus(false, 'Oracle connection failed');
            }
        }

        function updateConnectionStatus(connected, message) {
            const statusDiv = document.getElementById('connectionStatus');
            
            // Get current status to maintain both AI and Cloud status
            const currentText = statusDiv.textContent;
            
            let statusText = '';
            
            if (message.includes('Cloud') || message.includes('cloud') || message.includes('realm')) {
                // This is a database status update
                const aiStatus = currentText.includes('AI: ‚úÖ') ? 'AI: ‚úÖ' : 'AI: ‚ùå';
                const cloudStatus = connected === true ? 'Cloud: ‚úÖ' : connected === false ? 'Cloud: ‚ùå' : 'Cloud: ‚è≥';
                statusText = `${aiStatus} | ${cloudStatus}`;
            } else {
                // This is an AI status update
                const aiStatus = connected === true ? 'AI: ‚úÖ' : connected === false ? 'AI: ‚ùå' : 'AI: ‚è≥';
                const cloudStatus = currentText.includes('Cloud: ‚úÖ') ? 'Cloud: ‚úÖ' : currentText.includes('Cloud: ‚ùå') ? 'Cloud: ‚ùå' : 'Cloud: ‚ùå';
                statusText = `${aiStatus} | ${cloudStatus}`;
            }
            
            if (connected === true) {
                statusDiv.innerHTML = `<span class="connection-indicator connected"></span>${statusText}`;
            } else if (connected === false) {
                statusDiv.innerHTML = `<span class="connection-indicator disconnected"></span>${statusText}`;
            } else {
                statusDiv.innerHTML = `<span class="connection-indicator" style="background: #ffc107; color: #ffc107;"></span>${statusText}`;
            }
        }

        // UI Helper functions
        function updateGameStatus() {
            document.getElementById('turnCounter').textContent = turnCounter;
            document.getElementById('currentStatus').textContent = isListening ? 'The DM listens to your words...' : 
                                                                   isSpeaking ? 'The DM weaves your tale...' : 
                                                                   'Ready for your next legendary action!';
        }

        function updateSessionDisplay() {
            const sessionDisplay = document.getElementById('sessionDisplay');
            const startTime = new Date(parseInt(sessionId.split('_')[1]));
            sessionDisplay.textContent = `Epic Tale Started ${startTime.toLocaleDateString()}`;
        }

        // Keyboard shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ctrl/Cmd + Enter to send message
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    sendManualMessage();
                }
                
                // Space bar to toggle voice (when not typing)
                if (e.key === ' ' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    toggleVoice();
                }
                
                // Escape to stop any speech or close modals
                if (e.key === 'Escape') {
                    stopListening();
                    stopSpeaking();
                    closeSettings();
                }
                
                // Ctrl/Cmd + S to save game
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveGameState();
                }
                
                // Ctrl/Cmd + O to open settings
                if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                    e.preventDefault();
                    openSettings();
                }
            });
            
            // Allow Enter to send messages in textarea
            const manualInput = document.getElementById('manualInput');
            if (manualInput) {
                manualInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendManualMessage();
                    }
                });
            }
        }

        // Easter eggs and fun interactions
        function addEasterEgg(message) {
            const msg = message.toLowerCase();
            
            if (msg.includes('hello') || msg.includes('hi ') || msg.includes('greetings')) {
                setTimeout(() => {
                    addSystemMessage('üëã The Dungeon Master acknowledges your courteous greeting with a knowing smile!');
                }, 1000);
            }
            
            if (msg.includes('thank you') || msg.includes('thanks')) {
                setTimeout(() => {
                    addSystemMessage('üôè Your gratitude warms the DM\'s ancient heart like a cozy hearth!');
                }, 1000);
            }
            
            if (msg.includes('dragon') && Math.random() < 0.3) {
                setTimeout(() => {
                    addSystemMessage('üêâ You hear the distant roar of wings upon the wind...');
                }, 1500);
            }
            
            if (msg.includes('treasure') && Math.random() < 0.2) {
                setTimeout(() => {
                    addSystemMessage('üíé Your adventurer\'s instincts tingle with the promise of riches!');
                }, 1200);
            }
        }

        // Atmospheric effects
        function startAtmosphericEffects() {
            if (atmosphericEffectInterval) {
                clearInterval(atmosphericEffectInterval);
            }
            
            atmosphericEffectInterval = setInterval(() => {
                if (Math.random() < 0.1 && gameHistory.length > 5) { // 10% chance after some gameplay
                    const effects = [
                        'üïØÔ∏è Candlelight flickers in the ancient halls...',
                        'üåô Moonbeams pierce through stained glass windows...',
                        'ü¶â An owl hoots mysteriously in the distance...',
                        'üçÉ A gentle breeze carries whispers of old magic...',
                        '‚≠ê Stars align favorably for your quest...',
                        'üî• The hearth crackles with warmth and comfort...',
                        'üé≠ Shadows dance playfully on stone walls...',
                        'üåø The scent of herbs and ancient wisdom fills the air...'
                    ];
                    
                    const randomEffect = effects[Math.floor(Math.random() * effects.length)];
                    setTimeout(() => {
                        addSystemMessage(randomEffect);
                    }, Math.random() * 30000 + 10000); // Random delay 10-40 seconds
                }
            }, 60000); // Check every minute
        }

        // Auto-sync functionality
        function enableAutoSync() {
            if (autoSyncInterval) {
                clearInterval(autoSyncInterval);
            }
            
            autoSyncInterval = setInterval(async () => {
                const autoSync = document.getElementById('autoSync');
                const backendUrl = document.getElementById('backendUrl').value;
                
                if (autoSync && autoSync.checked && backendUrl && worldDatabase.characters.length > 0) {
                    const gameState = {
                        worldDatabase: worldDatabase,
                        gameHistory: gameHistory,
                        sessionId: sessionId,
                        turnCounter: turnCounter,
                        currentBattleMode: currentBattleMode,
                        currentBattleMap: currentBattleMap,
                        timestamp: new Date().toISOString()
                    };
                    
                    try {
                        const success = await syncToDatabase(gameState);
                        if (success) {
                            console.log('Auto-sync completed successfully');
                        }
                    } catch (error) {
                        console.error('Auto-sync failed:', error);
                    }
                }
            }, 5 * 60 * 1000); // Every 5 minutes
        }

        // Add header animation on load
        setTimeout(() => {
            const header = document.querySelector('.header');
            if (header) {
                header.style.animation = 'headerPulse 3s ease-in-out infinite';
            }
        }, 1000);
    </script>
</body>
</html>